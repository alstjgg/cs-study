## 1. Array
### 1)정의 및 특징 
- 인덱스를 가진 데이터의 집합으로, 같은 데이터 타입의 변수들로 이루어진 자료구조입니다. 
- Array의 가장 큰 특징은 ```배열 크기가 고정적이며, 메모리 공간을 연속적으로 구성``` 한다는 점입니다. (생성 시 고정값의 크기만큼 가지고, 이후에 크기를 늘리는 행위를 하려면 새로운 배열을 생성하여 내용을 복사해야 합니다.)

### 2) 장단점
**장점** : 인덱스 기반의 random access가 가능하므로 Access 타임이 O(1)
         특정 위치의 원소값을 수정하는 시간이 O(1)
                  
**단점** : 크기가 고정되어 있기 때문에 어떤 엘리먼트가 삭제되면, 해당 공간을 빈자리(null)가 남기므로 불필요한 메모리를 차지하게 됩니다.
         배열의 크기를 컴파일 이전에 정해주어야 하며, 컴파일 이후 배열의 크기를 변동 할 수 없습니다. 이것을 Static Memory Allocation이라고 부릅니다.


## 2.List
### 1) 정의 및 특징 
- 배열이 가지고 있는 인덱스라는 장점을 버리고, 빈틈없는 데이터의 적재 라는 장점을 취한 자료구조입니다. 
- Array와의 차이점은 ```1) 저장 공간 크기가 가변적이며```, ```2) 중간에 빈 공간을 허용하지 않고```, ```3)메모리에 분산되어 저장된다는 것```입니다.


### 2) 장단점
**장점**:
- 공간 크기를 동적으로 사용하기 때문에 공간을 미리 선언해 줄 필요가 없고, 빈 공간을 허용하지 않으므로 메모리를 낭비하지 않습니다. 
( 런타임에 공간 크기를 동적으로 선언하는 것을 Dynamic Memory Allocation이라고 부릅니다. )
- 포인터를 통하여 다음 데이터의 위치를 가르켜고 있어 삽입/삭제가 용이합니다.
        
**단점** : 
- 포인터를 통해 다음 데이터를 가르키므로, 참조를 위한 메모리가 추가적으로 필요합니다.
- 특정 위치 접근 시 맨 처음 노드부터 순차적으로 탐색해야 하기 때문에 접근 속도가 느립니다.
- 순차성을 보장하지 못하기 때문에 spacial locality 보장이 되지 않아 cash hit의 어려움이 있습니다.
*cf) spacial locality : 프로그램 실행 시 접근하는 메모리 영역은 이미 접근이 이루어진 영역의 근처일 확률이 높다는 프로그램 성격 표현


## 3. Array와 List 비교
### 1) 공통점
- 아이템들의 컬렉션입니다.
- 아이템들의 순서가 있습니다.

### 2) 차이점
**배열**
- 배열은 인덱스를 가지고 이 값은 유일무이한 식별자를 의미합니다.
- 배열의 할당된 메모리 공간은 연속적입니다.(조회가 빠르고, cache hit가능성도 큼)
- 배열은 데이터의 크기가 정해져 있고, 추가적인 삽입 삭제가 일어 나지 않으며 검색을 필요로 할 때 유리합니다. 

**리스트**
- 리스트는 리스트는 인덱스를 갖지만 이는 몇 번째 데이터인가 정도를 의미합니다.
- 리스트는 아이템들의 메모리 주소가 연속적일 수도 있고, 아닐 수도 있습니다.
- 리스트는 데이터의 크기가 정해져 있지 않고, 삽입 삭제가 많이 일어나며, 검색이 적은 경우 유리합니다.


### 3) 자바에서의 List
- 자바의 collection framework의 인터페이스 중 하나로 List를 제공하며,  LinkedList / ArrayList라는 2가지 형태의 리스트를 지원합니다.
*cf) collection framework: 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합

## 4. ArrayList
### 1) 정의
![LinkedList,ArrayList구조차이](https://user-images.githubusercontent.com/48278519/140638866-68be5c7f-84f5-4b54-a4df-63a22f31363d.png)
- ArrayList는 List 인터페이스를 상속받은 클래스로, 크기가 가변적으로 변하는 선형리스트입니다. 
- 일반적인 배열과 같은 순차 리스트이며 인덱스로 내부의 객체를 관리한다는점등이 유사하지만 한번 생성되면 크기가 변하지 않는 배열과는 달리 ArrayList는 객체들이 추가되어 저장 용량(capacity)을 초과한다면 ``자동으로 부족한 크기만큼 저장 용량이 늘어난다``는 특징을 가지고 있습니다.
- 내부적으로 배열을 사용하므로 ``물리공간과 논리공간이 동일``하고, 인덱스 연산자인 get / set 메소드를 통해 상수 시간으로 접근이 가능합니다. 
- 자바는 한 번 배열의 크기를 늘릴 때마다 ``기존 배열 x 1.5배``  만큼 늘립니다.( 좀 더 정확히 말하면, 기존 용량의 1.5배를 늘린 새 배열에 기존 배열을 copy합니다.)
```java
    // arrayList의 새로운 용량을 정하는 함수
    private int newCapacity(int minCapacity) {
        int oldCapacity = this.elementData.length;
        // 기존 용량 + 기존 용량/2 
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity <= 0) {
            if (this.elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { // arrayList가 비어있을 때
                return Math.max(10, minCapacity);
            } else if (minCapacity < 0) {
                throw new OutOfMemoryError();
            } else {
                return minCapacity;
            }
        } else {
            // 새로운 용량이 기존 용량의 +1 된 사이즈보다 크면
            return newCapacity - 2147483639 <= 0 ? newCapacity : hugeCapacity(minCapacity);
        }
    }

    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) {
            throw new OutOfMemoryError();
        } else {
            return minCapacity > 2147483639 ? 2147483647 : 2147483639;
        }
    }
```

### 2) 장단점
**장점**
- get()메소드가 지원되므로, 특정 원소 접근하는데 시간 복잡도가 O(1)
- set()메서드가 지원되므로, 특정 원소 수정의 시간 복잡도 역시 O(1)
- 빈 공간을 허용하지 않기 때문에, 메모리 공간의 낭비가 없음
         
**단점** 
- 원소 삽입/삭제 시간 복잡도는 O(n)
- add / remove 메서드가 수행될 때마다 저장 공간을 재할당 하므로, 맨 끝의 원소를 추가/삭제하는 시간복잡도 역시 O(n)이 걸림

### 3) 삽입 / 삭제 과정

#### 삽입 
![ArrayList삽입_1](https://user-images.githubusercontent.com/48278519/140638489-5c16855a-e971-40dc-a054-25836f44e9b8.png)
 ① 삽입할 자료만큼 공간을 늘리는 작업을 한다.
 
 ② 삽입할 자료의 위치를 기준으로 기존의 데이터들을 뒤로 or 앞으로 이동하는 연산을 수행한다.

 ③ 삽입할 위치에 자료가 입력되면 삽입연산을 마친다
 
 #### 삭제
![ArrayList삭제_2](https://user-images.githubusercontent.com/48278519/140638731-03901c33-375a-4f5a-b26f-f7aab372d520.png)

① 삭제할 자료가 위치한 인덱스의 자료를 삭제한다.

② 삭제한 자료의 인덱스를 기준으로 이후의 자료들을 이동하는 연산을 한다.

③ List의 맨 마지막은 비어있는 상태로 완료한다.


## 5.LinkedList
### 1) 정의 및 특징 
![LinkedList란](https://user-images.githubusercontent.com/48278519/140641899-bc7ca960-bc52-4260-a6a3-b4d74b05d79a.png)
- 연결 리스트(LinkedList)는 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식의 자료구조입니다. 데이터를 담고 있는 노드들이 연결되어 있고, 노드의 포인터가 이전 노드와 다음 노드와의 연결을 담당합니다. 
- ArrayList의 한계인 원소를 삽입 삭제시 시간 복잡도가 O(n))를 극복하기 위해 탄생했습니다. 
- 서로 주소를 연결하는 방식이기 때문에, ``물리 공간과 논리 공간이 일치하지 않고``, ``메모리 공간이 연속적으로 구성되어 있지 않는다``는 특징이 있습니다.

### 2) 장단점
**장점** 
- 원소의 맨 처음 삽입/맨 마지막 삭제 시간 복잡도는 O(1) (이전 노드와 다음 노드가 참조하고 있는 노드의 링크만 변경해주면 되며, 새롭게 저장 공간을 확장하거나 축소하여 재할당 해줄 필요가 없으므로)

**단점**
- 특정 지점을 접근하는 시간 복잡도는 O(n) ( 맨 처음 노드 혹은 맨 마지막 노드부터 찾고자 하는 위치를 향해 next 혹은 prev를 타고 가며 순차적으로 탐색해야 하므로)
- 리스트 중간에 삽입/삭제 시간 복잡도는 O(n) (마찬가지로 삭입 삭제할 위치를 찾아가기 위해 순차적으로 탐색해야 하기 대문)
     
### 3) 삽입/삭제

#### 삽입
![LinkedList삽입](https://user-images.githubusercontent.com/48278519/140638759-79206101-06b1-40f9-afa6-d570ea562c3e.png)

① 추가될 자료의 node를 생성한다.

② 추가될 자료의 인덱스 이전 node와 추가될 자료 인덱스 이후 node를 설정한다.

#### 삭제
![LinkedLst삭제](https://user-images.githubusercontent.com/48278519/140638823-58bc3b58-5208-4d7c-870f-6148e3faf52a.png)

 ① 삭제할 노드의 이전 노드와 이후 노드를 연결한다.

## 6. ArrayList와 LinkedList의 차이

| 비교 | ArrayList | LinkedList |
|---|---|---|
| get / set |	O(1)	| O(n) |
add(시작)	O(n)	O(1)
add(끝)	O(1)	O(1)
add(일반)	O(n)	O(n)
remove(시작)	O(n)	O(1)
remove(끝)	O(1)	O(1)
remove(일반)	O(n)	O(n)
 
선택하기
일반적으로 get/set을 자주 사용한다면? ArrayList
처음이나 끝에 잦은 삽입, 삭제가 발생한다면? LinkedList

 

하지만, 공간 복잡도의 경우 ArrayList는 연속된 메모리안에 저장되므로 낭비되는 공간이 없기 때문에 종종 속도가 더 빠른 경우가 발생하기도 한다. LinkedList는 요소마다 두개의 참조 노드가 필요하기 때문에 더 많은 공간을 차지하고, 메모리 여기저기 노드가 흩어져 존재하는 경우 효율이 더욱 떨어질 수 있으니 잘 선택하자!

## 6. 면접 질문 정리
### Array와 List의 차이는 무엇인가요?
- 배열은 인덱스를 가진 데이터의 집합이고, 리스트는 인덱스 없이 순차적으로 저장된 데이터의 집합입니다.
- 배열은 랜덤 엑세스를 통해 탐색 속도가 빠르지만, 데이터 삽입 삭제는 느립니다. 반면, 리스트는 랜덤 엑세스가 불가능하여 탐색 속도가 느리지만 데이터의 삽입/삭제가 빠릅니다.

### Array와 ArrayList의 차이는 무엇인가요?
- Array은 크기가 고정되어 있지만 ArrayList는 크기가 동적인 배열입니다.
- Array는 type와 object 모두 담을 수 있지만, ArrayList는 object만 담을 수 있습니다.
- Array는 element들을 할당하기 위해 assignment 연산자를 사용해야 하고, ArrayList는 add()메서드를 통해 삽입해야 합니다.

### ArrayList와 LinkedList의 차이를 설명할 수 있나요?
- ArrayList는 물리주소와 논리주소가 동일하며 메모리 공간이 연속적으로 구성되지만, LinkedList는 물리주소와 논리주소가 동일하지 않을 수 있으며 메모리 공간 또한 연속적으로 구성되지 않을 수 있습니다.
- ArrayList는 Index를 통해 특정 원소에 대한 랜덤 접근이 가능한 반면, LinkedList는 불연속적으로 위치한 각 요소들 간 주소를 연결하는 방식이기 때문에 특정 원소를 접근하기 위해선 순차 탐색을 해야 하므로 접근 시간이 느립니다.
- ArrayList는 데이터 삽입/삭제 시간이 느립니다.(삽입/삭제 후 기존 데이터들의 위치를 변경하고 삽입의 경우는 삽입 전 메모리 재할당을 해야하기 때문), 반면 LinkedList는 시작/끝 위치의 데이터 삽입/삭제가 빠릅니다.

### 데이터를 순차적으로 찾을때 가장 적합한 것은 무엇일까요?
- Array(List). 연속적인 메모리 공간으로 구성되기 때문에, 다음 인덱스 주소로 배열 요소에 빠르게 접근이 가능합니다. 
반면 LinkedList는 불연속적인 메모리 공간으로 구성되기 때문에 다음 데이터를 접근하기 위해서 다음 노드의 주소를 확인하면서 순차적으로 탐색하는 방식으로 오래걸릴 수 있습니다.  

### 데이터를 순차적으로 추가, 삭제할 때 가장 적합한 것은 무엇일까요?
- LinkedList. ArrayList는 순차적인 추가/삭제 시에도 저장 공간을 재할당 하므로 O(n)의 시간이 걸리지만 LinkedList는 가장 끝 노드를 삭제 후 이전 노드의 연결 정보만 수정하면 되므로 O(1)의 시간이 걸리기 떄문입니다.
 
### 데이터를 빈번하게 추가, 삭제할때 가장 적합한것은 무엇일까요? 
- 직전 답변과 동일( ArrayList는 매번 저장 공간을 재할당 하므로 오래 걸림 )
*) 만약 추가,삭제하려는 대상의 인덱스가 매우 크다면 ArrayList가 더 빠를 수도 있습니다.(해당 위치까지 접근하는데 오래 걸리기 때문)

### ArrayList나 List에서 중간에 데이터를 삽입하면 내부적으로 어떻게 동작하는지 아시나요?
-  추가할 자료의 노드를 생성한 후, 추가된 노드의 앞 노드의 연결 정보를 수정합니다.
-  추가될 위치의 이전 node의 다음 node를 새로 추가될 node로 설정하고, 추가될 node의 다음 node 정보는 추가되기 이전 node의 다음 node로 설정합니다.
   
### LinkedList는 이전 Node, 이후 Node의 정보를 어떻게 알까요?
- Node 구조체 안에 본인의 이전/이후 Node의 주소값을 저장합니다.

### ArrayList와 List 둘중에 검색속도는 어느것이 더 빠를까요?
- ArrayList. ( 직접 데이터 값을 확인하고 비교하는 건 둘이 비슷하겠지만 그 데이터까지 접근하는데 걸리는 시간이 더 빠름)


## * 결론
- 저장할 데이터의 개수가 정해져 있고 / 삽입, 삭제 작업이 적고 / 특정 위치의 데이터를 조회하는 작업이 많다면 Array
- 저장할 데이터의 개수가 미정이고 / 삽입, 삭제 작업이 많고 / 특정 위치 데이터를 조회하는 경우가 별로 없다면 List
- 인덱스를 이용해서 데이터를 가져오는 것이 빈번하다면 ArrayList 
- 데이터의 추가/삭제가 빈번하다면 LinkedList 

### * 추가 참고 자료
- [Java 심화] List 컬렉션에서 참조변수의 타입을 어떤 것으로 해야할까? (https://wonit.tistory.com/249)

### * 출처
- https://bb-dochi.tistory.com/9
- https://mong9data.tistory.com/132
- https://zorba91.tistory.com/287
- https://devlog-wjdrbs96.tistory.com/64
- https://shlee0882.tistory.com/95
